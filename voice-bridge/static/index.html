<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Claudia Voice</title>
<style>
  :root {
    --bg: #0f0f14;
    --surface: #1a1a24;
    --border: #2a2a3a;
    --text: #e0e0e8;
    --text-dim: #8888a0;
    --accent: #7c6fe0;
    --accent-glow: rgba(124, 111, 224, 0.3);
    --red: #e05555;
    --green: #55c080;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
    background: var(--bg);
    color: var(--text);
    height: 100dvh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  /* Header */
  header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 16px;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  header h1 { font-size: 18px; font-weight: 600; }
  .provider-select {
    background: var(--surface);
    color: var(--text);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 6px 12px;
    font-size: 14px;
    cursor: pointer;
  }
  .status {
    font-size: 12px;
    color: var(--text-dim);
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .status-dot {
    width: 8px; height: 8px;
    border-radius: 50%;
    background: var(--text-dim);
  }
  .status-dot.connected { background: var(--green); }
  .status-dot.recording { background: var(--red); animation: pulse 1s infinite; }
  .status-dot.speaking { background: var(--accent); animation: pulse 0.8s infinite; }

  @keyframes pulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.5; transform: scale(1.3); }
  }

  /* Transcript */
  .transcript {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  .msg {
    max-width: 80%;
    padding: 10px 14px;
    border-radius: 14px;
    font-size: 15px;
    line-height: 1.4;
    word-wrap: break-word;
  }
  .msg.user {
    align-self: flex-end;
    background: var(--accent);
    color: white;
    border-bottom-right-radius: 4px;
  }
  .msg.assistant {
    align-self: flex-start;
    background: var(--surface);
    border-bottom-left-radius: 4px;
  }
  .msg.system {
    align-self: center;
    color: var(--text-dim);
    font-size: 13px;
    font-style: italic;
  }
  .msg.tool {
    align-self: center;
    color: var(--accent);
    font-size: 12px;
    background: var(--surface);
    padding: 6px 12px;
    border-radius: 20px;
  }

  /* Controls */
  .controls {
    padding: 16px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    border-top: 1px solid var(--border);
    flex-shrink: 0;
  }
  .talk-btn {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    border: 3px solid var(--border);
    background: var(--surface);
    color: var(--text);
    font-size: 24px;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    -webkit-tap-highlight-color: transparent;
    touch-action: none;
  }
  .talk-btn:hover { border-color: var(--accent); }
  .talk-btn.active {
    background: var(--red);
    border-color: var(--red);
    transform: scale(1.1);
    box-shadow: 0 0 30px rgba(224, 85, 85, 0.4);
  }
  .talk-btn.speaking {
    border-color: var(--accent);
    box-shadow: 0 0 30px var(--accent-glow);
    animation: pulse-ring 1.5s infinite;
  }
  @keyframes pulse-ring {
    0% { box-shadow: 0 0 0 0 var(--accent-glow); }
    70% { box-shadow: 0 0 0 15px transparent; }
    100% { box-shadow: 0 0 0 0 transparent; }
  }
  .mode-toggle {
    font-size: 13px;
    color: var(--text-dim);
    cursor: pointer;
    user-select: none;
  }
  .hint {
    font-size: 12px;
    color: var(--text-dim);
  }
</style>
</head>
<body>

<header>
  <div>
    <h1>Claudia</h1>
    <div class="status">
      <span class="status-dot" id="statusDot"></span>
      <span id="statusText">Disconnected</span>
    </div>
  </div>
  <select class="provider-select" id="providerSelect">
    <option value="grok">Grok (~$0.05/min)</option>
    <option value="openai">OpenAI (~$0.18/min)</option>
    <option value="gemini">Gemini (free preview)</option>
  </select>
</header>

<div class="transcript" id="transcript"></div>

<div class="controls">
  <button class="talk-btn" id="talkBtn">ðŸŽ¤</button>
  <div class="mode-toggle" id="modeToggle">Mode: Push-to-talk</div>
  <div class="hint" id="hint">Hold button or press Space to talk</div>
</div>

<script>
const SAMPLE_RATE_OPENAI = 24000;
const SAMPLE_RATE_GEMINI_IN = 16000;
const SAMPLE_RATE_GEMINI_OUT = 24000;

let ws = null;
let audioCtx = null;
let micStream = null;
let workletNode = null;
let currentProvider = 'grok';
let isRecording = false;
let isHandsFree = false;
let isSpeaking = false;
let playbackQueue = [];
let isPlaying = false;

const transcript = document.getElementById('transcript');
const talkBtn = document.getElementById('talkBtn');
const statusDot = document.getElementById('statusDot');
const statusText = document.getElementById('statusText');
const providerSelect = document.getElementById('providerSelect');
const modeToggle = document.getElementById('modeToggle');
const hint = document.getElementById('hint');

// â”€â”€ Provider config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getInputSampleRate() {
  return currentProvider === 'gemini' ? SAMPLE_RATE_GEMINI_IN : SAMPLE_RATE_OPENAI;
}
function getOutputSampleRate() {
  return currentProvider === 'gemini' ? SAMPLE_RATE_GEMINI_OUT : SAMPLE_RATE_OPENAI;
}

// â”€â”€ UI helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function addMessage(text, role) {
  if (!text.trim()) return;
  const div = document.createElement('div');
  div.className = 'msg ' + role;
  div.textContent = text;
  transcript.appendChild(div);
  transcript.scrollTop = transcript.scrollHeight;
}

function setStatus(state, text) {
  statusDot.className = 'status-dot ' + state;
  statusText.textContent = text;
}

let partialAssistant = '';
function handleTranscript(msg) {
  if (msg.role === 'user' && msg.final) {
    addMessage(msg.text, 'user');
    return;
  }
  if (msg.role === 'assistant') {
    partialAssistant += msg.text;
    if (msg.final && partialAssistant.trim()) {
      addMessage(partialAssistant, 'assistant');
      partialAssistant = '';
    }
  }
}

// â”€â”€ Audio playback â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function queueAudio(b64data) {
  const bytes = atob(b64data);
  const buf = new Int16Array(bytes.length / 2);
  const view = new DataView(new ArrayBuffer(bytes.length));
  for (let i = 0; i < bytes.length; i++) view.setUint8(i, bytes.charCodeAt(i));
  for (let i = 0; i < buf.length; i++) buf[i] = view.getInt16(i * 2, true);
  playbackQueue.push(buf);
  if (!isPlaying) playNext();
}

function playNext() {
  if (playbackQueue.length === 0) {
    isPlaying = false;
    isSpeaking = false;
    talkBtn.classList.remove('speaking');
    setStatus('connected', 'Connected');
    return;
  }
  isPlaying = true;
  isSpeaking = true;
  talkBtn.classList.add('speaking');
  setStatus('speaking', 'Claudia is speaking...');

  const samples = playbackQueue.shift();
  const rate = getOutputSampleRate();
  const audioBuf = audioCtx.createBuffer(1, samples.length, rate);
  const channel = audioBuf.getChannelData(0);
  for (let i = 0; i < samples.length; i++) channel[i] = samples[i] / 32768;

  const source = audioCtx.createBufferSource();
  source.buffer = audioBuf;
  source.connect(audioCtx.destination);
  source.onended = playNext;
  source.start();
}

// â”€â”€ Audio capture (AudioWorklet) â”€â”€â”€â”€â”€
const workletCode = [
  'class PcmCapture extends AudioWorkletProcessor {',
  '  process(inputs) {',
  '    const input = inputs[0];',
  '    if (input.length > 0) {',
  '      this.port.postMessage(input[0]);',
  '    }',
  '    return true;',
  '  }',
  '}',
  "registerProcessor('pcm-capture', PcmCapture);",
].join('\n');

function resample(float32, fromRate, toRate) {
  if (fromRate === toRate) return float32;
  const ratio = fromRate / toRate;
  const len = Math.round(float32.length / ratio);
  const out = new Float32Array(len);
  for (let i = 0; i < len; i++) {
    const idx = i * ratio;
    const lo = Math.floor(idx);
    const hi = Math.min(lo + 1, float32.length - 1);
    const frac = idx - lo;
    out[i] = float32[lo] * (1 - frac) + float32[hi] * frac;
  }
  return out;
}

function float32ToPcm16B64(float32) {
  const buf = new ArrayBuffer(float32.length * 2);
  const view = new DataView(buf);
  for (let i = 0; i < float32.length; i++) {
    const s = Math.max(-1, Math.min(1, float32[i]));
    view.setInt16(i * 2, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
  }
  const bytes = new Uint8Array(buf);
  let binary = '';
  for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
  return btoa(binary);
}

async function initAudio() {
  if (!navigator.mediaDevices) {
    throw new Error('Microphone requires HTTPS. Use https:// or add this origin to chrome://flags/#unsafely-treat-insecure-origin-as-secure');
  }
  audioCtx = new AudioContext();
  micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
  const source = audioCtx.createMediaStreamSource(micStream);
  const blob = new Blob([workletCode], { type: 'application/javascript' });
  const url = URL.createObjectURL(blob);
  await audioCtx.audioWorklet.addModule(url);
  URL.revokeObjectURL(url);
  workletNode = new AudioWorkletNode(audioCtx, 'pcm-capture');
  workletNode.port.onmessage = function(e) {
    if (!isRecording || !ws || ws.readyState !== WebSocket.OPEN) return;
    const resampled = resample(e.data, audioCtx.sampleRate, getInputSampleRate());
    const b64 = float32ToPcm16B64(resampled);
    ws.send(JSON.stringify({ type: 'audio', data: b64 }));
  };
  source.connect(workletNode);
}

// â”€â”€ WebSocket â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function connect() {
  if (ws) ws.close();
  const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
  const basePath = location.pathname.replace(/\/$/, '');
  const url = proto + '//' + location.host + basePath + '/ws?provider=' + currentProvider;
  setStatus('', 'Connecting...');

  ws = new WebSocket(url);

  ws.onopen = function() { setStatus('', 'Authenticating...'); };

  ws.onmessage = function(e) {
    const msg = JSON.parse(e.data);
    switch (msg.type) {
      case 'connected':
        setStatus('connected', 'Connected \u2014 ' + msg.provider);
        break;
      case 'audio':
        queueAudio(msg.data);
        break;
      case 'transcript':
        handleTranscript(msg);
        break;
      case 'tool_call':
        addMessage('Searching: ' + msg.name + '...', 'tool');
        break;
      case 'tool_result':
        addMessage('Found: ' + msg.result, 'tool');
        break;
      case 'error':
        addMessage('Error: ' + msg.message, 'system');
        setStatus('', 'Error');
        break;
    }
  };

  ws.onclose = function() {
    setStatus('', 'Disconnected');
    setTimeout(function() {
      if (!ws || ws.readyState === WebSocket.CLOSED) connect();
    }, 3000);
  };

  ws.onerror = function() { setStatus('', 'Connection error'); };
}

// â”€â”€ Recording controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startRecording() {
  if (isRecording) return;
  isRecording = true;
  playbackQueue = [];
  isSpeaking = false;
  isPlaying = false;
  talkBtn.classList.add('active');
  talkBtn.classList.remove('speaking');
  setStatus('recording', 'Listening...');
}

function stopRecording() {
  if (!isRecording) return;
  isRecording = false;
  talkBtn.classList.remove('active');
  setStatus('connected', 'Processing...');
  if (!isHandsFree && ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: 'commit' }));
  }
}

// â”€â”€ Event handlers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
talkBtn.addEventListener('pointerdown', function(e) {
  e.preventDefault();
  if (isHandsFree) {
    isRecording ? stopRecording() : startRecording();
  } else {
    startRecording();
  }
});
talkBtn.addEventListener('pointerup', function(e) {
  e.preventDefault();
  if (!isHandsFree) stopRecording();
});
talkBtn.addEventListener('pointerleave', function(e) {
  e.preventDefault();
  if (!isHandsFree && isRecording) stopRecording();
});

document.addEventListener('keydown', function(e) {
  if (e.code === 'Space' && !e.repeat && e.target === document.body) {
    e.preventDefault();
    if (isHandsFree) {
      isRecording ? stopRecording() : startRecording();
    } else {
      startRecording();
    }
  }
});
document.addEventListener('keyup', function(e) {
  if (e.code === 'Space' && e.target === document.body) {
    e.preventDefault();
    if (!isHandsFree) stopRecording();
  }
});

modeToggle.addEventListener('click', function() {
  isHandsFree = !isHandsFree;
  modeToggle.textContent = 'Mode: ' + (isHandsFree ? 'Hands-free (VAD)' : 'Push-to-talk');
  hint.textContent = isHandsFree
    ? 'Tap button to start/stop \u2014 VAD detects speech'
    : 'Hold button or press Space to talk';
  if (isRecording && !isHandsFree) stopRecording();
});

providerSelect.addEventListener('change', function() {
  currentProvider = providerSelect.value;
  partialAssistant = '';
  connect();
});

// â”€â”€ Load available providers â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function loadProviders() {
  try {
    const res = await fetch(location.pathname.replace(/\/$/, '') + '/config');
    const data = await res.json();
    const costs = { grok: '~$0.05/min', openai: '~$0.18/min', gemini: 'free preview' };
    // Remove existing options
    while (providerSelect.firstChild) {
      providerSelect.removeChild(providerSelect.firstChild);
    }
    let first = null;
    for (const p of data.providers) {
      if (!p.available) continue;
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name + ' (' + (costs[p.name] || '') + ')';
      providerSelect.appendChild(opt);
      if (!first) first = p.name;
    }
    if (first) {
      currentProvider = first;
      providerSelect.value = first;
    }
  } catch (e) {
    console.warn('Could not load provider config', e);
  }
}

// â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function init() {
  await loadProviders();
  await initAudio();
  connect();
  addMessage('Tap the mic button or hold Space to talk to Claudia.', 'system');
}

init().catch(function(e) { addMessage('Init error: ' + e.message, 'system'); });
</script>
</body>
</html>
